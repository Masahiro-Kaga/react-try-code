100
　
　通常、コンポーネント内エレメントは全て、<div>…</div>のように囲まなければならない。div soupと呼んでいる。
　ただ、それを解決する一つの方法として、エレメントで囲まずに、配列型にすることで可能になる。詳細コードはビデオ内にて。
　しかし、この方法だと配列の結果を返すことになるので、map()同様、子コンポーネントにkeyプロパティを作ってやらないとエラーが発生する。
　
return (
    <div>
      {error && (
        <ErrorModal ....
    </div>

↓↓↓↓↓↓↓↓↓↓

return (
    [
      {error && (
        <ErrorModal ....
    ]

101
　もう一つのdiv soupを避ける方法として、Wrapperコンポーネントを個別に作成。
　
102
　さらに２つ。
　１　空のタグ  <>...</>　でも実はオッケー。でもプロジェクトによって機能しないこともあるとか？
　２　Reactをあらかじめインポートしておきつつ、<React.Fragment></React.Fragment>、
    もしくは、React,{Fragment}からの、<Fragment></Fragment>

103
　モーダルが普通のコンポーネント（この場合はAddUsersコンポーネント内に、ErrorModalがあって、その隣に他のコンポーネントがある）と隣り合って、オーバーレイするのは、コード的に不適切ということ。
　だったらモーダルをrootと同じトップのレベルに持っていく必要があるとのこと。

104
　createPortal:使い道としては、ポップアップ・モーダルなど、全く別個でDOM上の位置を取りたい時。
　
　他にも「バラバラな位置に入るサブコンポーネントをまとめて管理したい場合」とのこと。

　まずは一つのファイルに、二つのコンポーネントを作成（Backdrop/ModalOverlay）。
　次に一つのコンポーネントに集約するが、その際、ReactDOM操作が必要になるので所要の処理をする。
　キーポイント・トリッキーな部分として、上の二つのコンポーネントのタグ内に、必要なプロパティがあれば付け加えること。なぜなら、

　１　一段ずつ、コンポーネントが増えたから、プロパティの新たな継承（Backdrop/ModalOverlay　→ ErrorModal）が必要。

　２　AddUserコンポーネント上で、Backdrop/ModalOverlayの親であるErrorModalを発動させるためのif(error && <ErrorModal>...)があるため。→ つまり、htmlはDOM操作によってroot階層にいく（レンダーされる）けど、関数とかプロパティを操作するのは各コンポーネント間でやりとりされる。

105
　useRef:使い道としては、inputのデータ抽出及び文字・値の代入。
　
　useStateの代わりになるし、毎回ユーザが入力するたびにonChangeでコンポーネントが更新されることを避けられる。かつ、コードの省力化も可能。

　const **** = useRefで、参照させるためのポインタのようなものを作るところから始まる。
　その後、inputのプロパティフィールド内にて参照設定（DOM操作、inputのオブジェクト変数が完成）する。
　そして、そのオブジェクトで値を取ったり入れたり。
　
　useRefには、そのinputの中に文字・値を入れられる機能もあるので、'value='などの2way bindingも必要ない。

