199

以前と同様、キーストロークするごとに、enteredNameが更新される。
さらに、useRefを使って、フォームをサブミットした際に、enteredNameとenteredValueの変数がコンソール発火するものを作る。
フォームをサブミットしたのち、2way binding により、inputの中を空白に戻す必要がある。
    nameInputRef.current.value = ''
    でも可能らしいが、直接DOMにアクセスするから好ましくないとマックスが言っている。


200

trimを用いて、サブミット時に空欄であればfalse、そうじゃなければtrueの式を作る。


201

stateがtrueとfalseのときに、if関数を用いて、<p>と各クラス（divとpの中に）を追加してvalidateを有効にする。
便宜上、enteredNameIsValidの初期値をtrueにしているが、本来は、ページがリロードされた際には何も入っていないので、初期値はfalseでなければならない。でもそうすると、validateが働いて、最初から赤字で警告が出ている状態になってしまう。
初期値trueのままでも良いが適切な挙動ではないので、次のレクチャーで修正。


202(若干トリッキーかも)

enteredNameTouchedを設定することにより、submitボタンが押された時に初めて、validateが働くようにする。
なお、useEffectがあるが、これは特に機能には関係してこないので、入れなくてもいい（ただのテスト用）。
ここで言うtouchedの意味としては、input内にカーソルを入れた、という意味で、その後ボタンを押したり離したりしたらこの値が変わるようにコードを打つ。

enteredNameIsValidがfalse、enteredNameTouchedがtrueの時に発火するようにするが、この組み合わせを変数に置いて効率よくしている。


203

submitした際のvalidate機能は実装済みだが、例えば空欄にしたのちにカーソルを外すとエラーが出るようにもしなければならない。onBlurの出番。


204

かつ、上記でエラーがでてしまったあと、カーソルをまた戻してタイピングをはじめたら、エラーが解除されるようにするのが適切。
さらに、その他のコードをオプティマイズする。例えば、returnは、if以降コードが何もなければ削除すべき。
enteredNameIsValidのstateを削除。理由は、enteredNameのstateさえあれば、
　const enteredNameIsValid = enteredName.trim() !== '';
の変数を作るだけで、enteredNameがステート変更したらその変数も更新されるから、IsValidのステートは必要ない。
その他、コードの無駄を省くのは結構難しい。


205

submitボタンをdisableのアトリビュートを追加して、バリデーションによってトグルさせる。
レクチャーでは、フォーム全体が有効か無効かと言う表現をしている。
どういう時にボタンを押せるようになればいいのか、答えは簡単で、enteredNameIsValidがtrueであれば良い。
CSSの書き方も要チェック。
このセクションでは、別に違う変数を新たに設定しなくても（enteredNameIsvalidのみ使うことでも）、全然同じ挙動になった。用途をしっかりと定めるために、正しい変数とその名前を設定すると言うこと。ただし、次のセクションで、form全体がvalidかそうでないかを判定するための変数を設定しなければならないことが判明する。


206

Nameにならって、Email欄を作成してみる。
validateの内容としては、@が入っているかどうかの判定のみ。

１　Formの形を作る。
２　文字を打つたびに、変数に文字を入れるuseStateを作る。
３　＠が入っているかどうかのバリデーションを作る。
４　カーソルから離れた際に、Falseを返す機能を搭載する。
５　条件３と４（カーソルが離れた、かつ＠が入ってない）の条件が揃ったらInvalidになると言う条件の変数を作る。
６　その５の変数がtrueのときとそうでないときで、formのclassを適用させたりさせなかったりする。これもまた変数として作成して、その変数を必要な要素の中のアトリビュートに組み込む。
７　（上記205セクションでペンディングとなってた）formIsValidの変数を用意して、nameとemailともにvalidであればボタンを有効にする設定をする。
８　ボタンを押下した際に、変数やインプットの中身をデフォルトに戻す。


207

nameとemailの項がほぼ同じなため、カスタムフックを作成する。
１　カスタムフック用のフォルダとファイルを作成。
２　どの部分を共通部分としてカスタムフックに組み込むことができるか見極めて、カスタムフックの中にステートや変数などを入れて、returnで返すものも設定する。なお、returnで返すものは、オブジェクト形式とする。理由は４冒頭。
    returnで返して向こうに渡さなければならない変数とそうでない変数（ex enteredValueTouched）を分ける時の基準は、渡す先のファイルで実際に共通部分（カスタムフックで設定する部分）を削除した後に残るであろうコードの中に、その必要な変数等が残っていたら、それはカスタムフックから渡されるべき変数等である、と言うことが言える。
    ※ event.preventDefault();　直下のsetEnteredNameTouched(true)は、早い段階で必要なくなっているものなので、そのまま何も考えずに削除。

＊難ポイント＊
３　カスタムフックを使うベースとなるファイルで、独自の変数やファンクションがある場合の取り扱い。
    今回のケースは、nameに対してtrim()、emailに対してincludes('@')と言うファンクションがそれぞれ設定されていて、そのファンクションを使って出された結果（データ）を、カスタムフックの中で使用すると言う想定。
（１）use-input.js
    const useInput = (validateValue) => {
            const valueIsValid = validateValue(enteredValue);
    validateValueは、カスタムフックを呼び出すもとファイルの中にある各独自ファンクションで、このカスタムフックの中からenteredValueを引数として使う、という想定。
（２）SimpleInput.js
    const {
        value: enteredName,
        isValid: enteredNameIsValid,
        hasError: nameInputHasError,
        valueChangeHandler: nameChangedHandler,
        inputBlurHandler: nameBlurHandler,
        reset: resetNameInput
     } = useInput(value => value.trim() !== '');
     useInputの中の引数にファンクション等が入っている。問題はこのvalueと言う変数。例としてこの名前を使うのは個人的には好ましくないと思うが（上でもvalueと言う名前を使ってるから）、このvalueと言うのは、上と同じではなくて、カスタムフックから持ってきた引数にあたることに注意。
     この引数の中で処理された結果を、またuse-inputのカスタムフックに戻して、それ以降のコード
     （const hasError = !valueIsValid && isTouched; よりも下のコード）を走らせる。

４　カスタムフックにて、オブジェクト形式でデータが渡されたので、渡された先で、カスタムフックを呼び出す。
　　その際、オブジェクト形式なので、defrastracture（解体）して、それぞれ変数やファンクションを任意の名前と一緒に設定する。なお、もう必要のない変数とかステートとかは、カスタムフックの中の変数やファンクションなどを一つ一つ実装していきながら、それに対応する必要のないものを消していく方が混乱しなくてよい。効率の良い変数際割り当て方法は、ターミナルに出現するエラー表示”**** is not defined”　を一つずつ潰していくと言うのが良い。

５　上記変数やファンクションを実際に適用させていく。


207 

nameと同様に、emailを実装。


208 

BasicForm.jsは、練習用に用意されたファイル。フロムスクラッチから、もう一度やってみよう、と言うものなので、スキップしてもオッケー。


209,210

基本的には、BasicForm.jsの答え合わせ。
だが、
@@@@@@@@@@@@@@
Formik
@@@@@@@@@@@@@@
と言うフレームワーク、ライブラリの紹介があるので、Don't miss it.
https://qiita.com/macotok/items/df1fdcac02e64638d9c8


211

useReducerを使って、カスタムフックのコードをもっとスッキリさせる。



